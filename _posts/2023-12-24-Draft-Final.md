---
layout: post
title:  "Assignment 10: Final"
date:   2023-12-24 14:00:00 +0200
categories: Assignment
--- 

# Introduction

For this project the idea was to build a drone. Of course this is not some new concept, as it is more intended to be a challenge for a person who is coming from a background in computer science. Other than just building a drone I also want to build the controller for it. The reason is that i would have more controll of what kind of data is being sendt to the drone. By having two seperate systems i have the option to develop both systems at the same time or to focus on one at the time.

This project was originally started before taking this course. Due to me wanting to highlight the knowledge gained in this course and how it has been applied to the project, the earlier work is neglected for this report and barely mentioned. Although I want to focus on what i have learned in this course, it would be more correct to say during this course as i have gone outside curriculum multiple times, and done things before it was introduced in the course.

# System Implementation
The drone that this project is going to build is a quadcopter, meaning it has 4 motors and 4 propellors. Each motor is connected to a ESC which is then connected to the arduino. The arduino serves as logical controll unit on the drone, and manages every other component. This also includes radio communication with the controller and a sensor(MPU6050) which has a gyro and accelerometer. The arduino takes data from the radio and uses it to controll the drones direction of movement. It also takes data from the sensor and uses it to balance its tilt.

The controller consists of two joysticks and a radio. This system is also using an arduino as its logical controller, so a large part of this project is to get reliable radio communication between two arduinos. The arduino reads the input from the joysticks and then sends it to the drone.

# Digital Fabrication

A large part of this project has been done in some kind of digital fabrication software. This project has alot of electronic parts that needs protection and housing. If one were to breakdown this to its simplest form of abstraction, I have created two boxes which contains electronics. These boxes however is made so the lid is removable. This was done with "threaded inserts", which is screw holes made out of metal that you insert into 3D printed objects by melting them in place. By doing this you actually solve the biggest problem I have found with 3D printed designs. 3D printing is really bad at any kind of overhang, so bad that all slicing programs that I have used have algorithms that add support to existing builds. This support is something that one break of the design afterwards. This of course is wasteful and takes more time to print.

A consideration one have to make when combining digital fabrication and physical objects is making sure everything is messured correctly. Multiple times I ended up approximating meassurments and it ended up being off by some milimeters and i had to redo the design. I quickly learned that any kind of rounding leads to parts not fitting together. When messuring screwholes one needs to be really exact as the tolerance for error is really small. This was especially the case when mounting joysticks onto the controller. 

In terms of functionality the most useful fabrication technique i have used is designing circuit boards. How i see it, there are 3 levels of working with electronics. First level is just connecting wires between components. Next level is using breadboards, with this you are forced into more structure as things are usualy contained on the same breadboard, but you gain more flexibility that you can use to create more advanced circuits. Next level is designing a circuit board and soldering components onto the board. With this the circuit takes much less space and everything is secured in one place. For the drone this is really important. The motors on a drone operates with an RPM above thousands. Any movable part on the drone could experience large amount of stress, due to the vibrations the motors produces. Because of this soldering electrical components to a circuit board is integral for the durability of the system. In terms of space managment this solution made it so the box containing the electronics could fit on its foundation and also be somewhat aerodynamic.

Since its important to reduce stress on the system, having an exact fit between the circuit board and the box is important. This introduces a challenge in having accurate measurements. The first circuit board I designed for the drone I somehow messured wrong so I had to reduce the size of the circuit board by filing down the edges. I also ended up mixing up connections so i had to tape a component onto the circuit board. Making mistakes on a circuit board is much more punishing than something that is 3D-printed. You can always just reprint something, but with a circuit board i have to order a new one and then wait for it to arrive. Luckily the shipping is only a week which loosely falls under rapid prototyping.

An alternativ to create an exact fit could be to create holes in the cicuit board and then screw it onto the 3D-printed box drone box. For some reason I wanted to have an exact fit, and kinda still do now that I have tried multiple times to achive this over multiple projects. I have noticed that my teacher for this course is usualy using a screw and a bolt to combine two parts. This is something i should start to do as its just fast and simple. I think i still prefere to have metal screwholes as i think its more aesthetically pleasing. I have also seen people screwing metal straight into plastic creating contact point between plastic and metal. I really dont see how this is any good due to how little reusable this is for wood. If you were to take a screw out of wood, that hole is almost no longer usable. Plastic is way worse because the inside not solid most of the time. 3D-printed object are a hard shell with support inside. One would have to use more infill and be content with never removing the screw to do this.

During the project i strongly considered building a testing rig for drone stabilization testing. This would work by attaching the drone on a pivot point. Then i could easily test software and see if its able to stabilize on its own without me flying it and risking destroying parts Out of the two fabrication methods we learned about in this course one method is way faster and produces material more capable of this task. This method is laser cutting, it allows for fast production of larger pieces and since it is out of wood(or metal) it should handle being strapped between a table and the drone.

# Physical Computing Application

As mentioned in [Introduction](#Introduction) the basis of the project is comunication between two arduinos. In reality any component that is able to do computation and has memory could do this task. The reason arduino was chosen for this is because of how easy it is to use. The community around arduino is amazing and there are alot of modules and open souce libraries. The radio module i am using(nRF24L01) has an arduino library that allows me to create an array, and then send the whole object in one go. Without this library i would have to go down on the byte level and encode and decode packets of information. 

The main role the arudino serves is managing how much power goes into the motors(actually controlling the ESC's(electronic speed controllers)). Using the data recived from the radio on the drone side, power output is then given to the motors. Another goal for this project was to have the drone auto level. Without auto level the drone would be prone to flipping. Any external force(wind) on the drone whilst in flight would tilt the drone slightly and it would immediately flip(i think, gravity might play a part). Therefore i use a sensor(MPU6050), which has a accelerometer and gyro. The arduino should then take the data from this sensor to autonomously adjust power given to the motor to prevent it from flipping, or just keep it at the desired level of tilt.

Something that is really important when designing this kind of system is making sure everything operates smoothly and everything is responsive. How an arduino executes code is by running a function called loop() on repeat, everything that is executed more than once is inside this function. Therefore it is important to make sure nothing is blocking or taking too much computing time. A common practice on an arduino when you want to limit how often something happens is by blocking the CPU by making it wait. This is fine when there is only one component running, but on the drone there are 3 seperate parts working together(MPU, Radio, Motors). The MPU(gyro and accelerometer sensor) is really important and needs to sample data as often as possible, if possible the sample rate should be maximized and other not so important parts should limited. The MPU output is directly affecting the motors, if motors are limited then there might occour a delay in the stabilization and it would work suboptimal. The radio however is not so important, it only affects how responsive the drone seems, but as long its not limited too much it should not be noticable for humans. The limiting is done by checking current time each loop, if current time is larger than last time the radio code was executed and a interval constant then radio code can run once. This interval can be changed if the controllers does not seems responsive enough. 

To actually fly the drone it obviously needs to be powered. During its development the arduino was powered through usb, and the motors was powered through a stationary power supply. The usb connection is how code is uploaded to the arduino and also used for plotting data through serial print. Stationary power supply is helpful as you can set how much volts that is being sendt and you can see how much amps the system draws. When flying the drone, this needs to be changed. The input pin on the arduino(vin) has a recommended range of 7 to 12 volts, whilst the motors require higher voltage to operate optimal. Therefore a step down voltage regulator(buck converter) was used. I should probaly learn more about how this is done, but this was the one component that just worked on the first try without any effort. The output voltage was monitored with a voltmeter whilst turning a know untill a desired voltage was given.


# Interaction Design

Every control device for a drone i have seen uses some kind of joysticks. Some drones are controlled via a phone app, and they use touch screen based joysticks. There is a good reason why joysticks are used. I would say the biggest reason i decided to order joysticks rather than just use buttons that i already had many of, was because they are intuitive, easy to use, and has a wide range of different values that can be used. Having something that outputs a range of numerical values as opposed to only binary values is beneficial when the motor input values also is a range of numerical values. Also when letting go of the joysticks they return to their orignial position (original value) which mean you don't have to think about implementing a toggle system you would have to do with buttons. A single joystick has 5 usable variables and two of the variables are an inverse of two of the other variables, just like on a drone. You can not steer a drone left and right at the same time, and same with forwards and backwards.

This course has had focus on interacting with our device through internet(internet of things device (IoT device)), but if i were to do this then it would be the same as just using buttons. Probably the most ideal configuration for controlling the drone through web would be with WASD and arrow buttons. By doing this i would not have the advantages of using joysticks. Another alternative would be to develop a phone app with touchscreen joysticks, then i would have the advantage of joysticks. The reason why i have not done this is because apps are out of the scope of the course and i have no prior experience with app development. Having a phone app is actually more advantageous than the current system. If i were to attach a camera on the drone, then i would already have a screen to display the video feed. It would also be more easy to use as currently i need to connect the controller to a pc, with an app i only need my phone and the drone.

Actually developing the user interface was a bit challenging prior to this course. The joystick i was using was branded as an arduino module but there was no clear easy way to attach them to something. Prio to this course my solution was to just plug them directly in a breadboard, but as you can see from attached picture this was not ideal. In retrospect what i should have done was to just attach them to a piece of cardboard or similar. When i first learned about 3D-printing as a fabrication method i quickly printed a flat rectangle and used screws and bolts to attach them. The final design is really similar but now the rectangle is now a lid for the controller box.

Attachement 1 and 2 shows the difference in physical design for the controller before and during this course.

Attachement 3 shows the interaction flow between the different components. This system facilitate user interaction by having real time response to input via the joysticks. Due to the considerations made in [Physical Computing Application](#physical-computing-application) user interaction with the design should still feel responsive enough whilst not limiting the drones ability to selv stabilize.

# System evaluation Q7

Just starting to build a drone can be daunting, especially when considering how complex some of the drones in the marked are. Luckily a drone consist of multiple independant sub-systems which means in reality one could start anywhere. The first thing I started to develop was communication between two arduinos through radio. At that point I was using two breadboards and a LCD(Liquid Crystal Display) to display information. Once this was working consistantly I added joysticks and sendt that information to be displayed on the LCD. Untill that point everything has been plug and play, but the next step was to include motors. This required external power supply, soldering, and planing behind every test. Just like the rest of the class i had huge difficulties with power and soldering. At somepoint a random professor found me wandering the halls of my school and taught me how to solder. He also told me how to power the motors which i would have spent alot more time to figure out without help. He also taught me how to use a multimeter which is a really useful tool that i should have been using earlier, and still often neglect using.

Everything done to that point was prior to taking the course. This however, does not mean i did little during the course. I had many errors that resulted in the drone being unreliable or not functioning that i had to fix. The biggest error was discovered when I was using a external power supply thats not a battery. Using this i was able to select voltage, and monitor amps usage whilst having a power off button. I noticed that the airflow from the drone was pushing down and upwards at the same time. The mistake i had made lead me to discover how motors worked and that i had to reverse the polarity to make the motor spin the correct way. There was also some error with the radio, sometimes it would not send anything. This must have been something wrong with the connections because it stopped once i switched to circuit boards.

By employing different computational tools and techniques it allowed my workflow to be incredibly dynamic. Whilst building the electronics for the project, i iteratively changed the CAD model to fit the changes i made to the electronics. If i miscalculated something i could quickly change the CAD design and reprint the part(drill a hole in the original model first whilst i wait for the print to finish). If something was done incorrectly with the electronics i could quickly change the model in KiCad(ended up breaking a wire cutter whilst attempting to reduce the size of the circuit board. I also ended up using tape to attach parts to a faulty made circuit board, and use hotfix soldering solutions). All this made it so whilst i worked on the project i was not stuck in one module trying to get something to work, i was actually using everything at once. It also allowed me to have a deeper insight to what every part of the design was doing, which i think made this project easier than it should have been. I imagine if i just focused on one module at the time i would have difficulty trying to get everything to work together in the end. Thats atlest the impression i got when talking to other people in my class. Some people were so focused on just the CAD design that the rest of the system is not yet working in the last weeks of the semester.


# Discussion

Although building a drone is not innovative and has been done multiple times in the DIY community, i would argue that the innovative part of this project is how in depth it went. Most drone guides found online skips over multiple parts and is reduced to assembly of components where one is not able to change much. Creating a controller and coding the communication instead of buying a controller, and creating circuit boards instead of using breadboards is something no other guide is doing(that i have found). Given that i have been able to document the process and struggles that have come with creating a custom circuit board and building a controller, one should loosely be able to accomplish the same. This project also serves as a good bridge to electronics for someone who has a background in computer science(engineering?), since the result is something modular(modular in the terms of the builder can add more things).

The main problem solving strategy that was used during this project was mainly trial and error, and i want to highlight this point with the process of developing the auto stabilization system, which has been the biggest challenge of this project. This section is an after documentation showing my thought process and lead to one of the most important discoveries, which is why i decided to stitch it into this text.

"After the processing of raw sensor data what i end up with is tilt in x and y axis. From this i created a system with 4 variables, positive and negative xy. This means that power of front right motor would be determined by positive x and postive y variables. The tilt to power converter most likely needs to be a non linear function, but for simple testing it is linear. The reason why i think it should not be linear is because i assume the higher tilt the drone has the more power it should give to correct the tilt. A linear function works for this of course, but i am not sure the rate in change is enough. Therefore i want to end up with an exponential function, but all this is something i will find out whilst testing. Right now i multiply tilt in degrees with 15. The power range i am using for the motors are 0 to 1000. Meaning a tilt of 66 degrees would result in max power output. The tilt would not alone reach the max because some of the power would be required to keep the drone of the ground. If it was a seperate power output, then i would have 45 degrees give max power output. Right now i dont know what the minimum for lift is, so this should be enough for testing.

From this i performed on the ground flight testing for stabilization. By on the ground i mean that power cables prevent it from flying freely and of course my arm holding it. When i tilted the drone diagonal in two of the direction i felt a noticable force pushing it upright. But the two other diagnoals it tried to tilt even more in that direction. When i tried to tilt the drone straight into x or y axises it wanted to turn against the clock. I originaly thought i had assembled the propellers wrong somehow. In the motor kit i bought there are two identical motors and propellers, so this could not be the case as propellers cant be assembled on the wrong motor. This could only mean that two of the motors rotate the wrong way. I noticed that air flow from two of motors was pushing upwards, and when i checked which way they rotated, i saw that they all spun with the clock. 

After doing some research, a motor is from my new understanding an electrical field that rotates a magnet, this magnet in this case is attached to the rotors that spins. This electical field can be reversed by flipping power and ground. By flipping the direction of the electrical field the magnet or rotor spins the opposite direction. With this fixed the motors are pushing the drone upright when i attempt to tilt it. When i performed "flight" tests before implementing auto stabilization system i thought the reason why the drone was rotating on the ground was because the motors was not calibrated correctly, but now i know it was because i failed to check if i had done the assembly of the drone correctly. 

Attachement 4 is a video of the first real flight with auto stabilization system. As you might notice the test was not perfect, but it did show great potential. Just before this test i implemented a emergency power off button. I had to implement this because if the drone were to flip the motors would rotate based on the tilt and i would have to unplug the battery. This test proved that the system worked perfectly. Another concern was if i had enough lift. Based on the momentum the drone had before i managed to turn off the power i would say the power is sufficient.

After some more testing with the aid of the course teacher which can be found under attachement5, the conclusion was that I had implemented parts of a PID controller, but only the P part. The part of the PID controller I had accidentally implemented was over shooting and I had to regulate the factor I multiplied the tilt or error with. At this point the advantage of trying to maximize the amount of times the MPU reads data over a second comes into play. The I and D part stands for integration and derivation meaning you most likely have to do some wierd math with the error. By only sampling two points(last and current) a linear function can be created. With a linear function an analytical solution can be found instead of using some wierd approximation to solve derivate and integral of points."

Currently there are two types of commercial drones on the marked, aerial photo drones, and racing drones. The drone that i have developed so far is not capable of taking pictures, and due to its size and weight it is not suited for racing. The strenghts of this drone however, is that since i created it, adding capability for photography should not be too difficult. Reducing the weight is also a possibility since something that i wanted to was 3D-print the entire drone frame. With enough fine-tuning this drone could become as the one found on the marked

# Conclusion and Future Work

Given more time for this project a testing rig for stabilization would be the first focus. This is something that i should have developed really early, since testing by holding something that is capable of multiple thousand RPM is not the most safe thing to do. Not having a rig for testing is most likely the reason why i was not able to complete this project during the span of the course. Rapid prototyping meant that I were able to manufacture and perfect the design with little time loss. But a lack of rapid testing meant that functionality got down prioritized as i had to go outside and risk damaging the drone to do test flights.

Something that could be interesting to implement is camera. Since i have claimed the design is modular(modular in the sense that i built it), there should be an attempt to attach a camera onto the drone. The radio module I am using is an transceiver, meaning it could send and recieive data. Therefore it could be possible to send images over radio. Figuring out how many bytes i realistically could send over radio over the course of one second could be a really cool challenge that goes back to my previous degree in computer science(engineering). Additionaly a display could be attached to the controller to give a live feed of what the drone sees.

Point is that the drone developed so far is a really crude version of what one could buy for way cheep. Therefore it has almost infinitly degree of potential improvements.
